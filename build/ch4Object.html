<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>App</title>
  </head>
  <body>
    <!-- add the following div only in the react section -->
    <h1>Chapter 4 Data Stuctures: Objects and Arrays</h1>

    <h3>Data Sets</h3>
    <p>To represent digital data jnto machines memory</p>
    <p>Data type to storing sequences of values is called Array.</p>
    <em>Check console log for example of Array</em>

    <h3>Properties</h3>
    <p> Function to get length of string = myString.length(length to get the length of a string )</p>
    <p> We cannot access values that have null or undefined properties. </p>

    <h3>Methods</h3>
    <ul> Sample of method :
      <li>.toUpperCase()</li>
      <li>.push() </li>
      <li>.pop()  </li>
      <li>.join() </li>
      <li>.pop()  </li>
    </ul>

    <h3>Objects</h3>
    <p> One way to create an object is by using a curly brace notation.</p>
      <em>Please inspect element to check the sample
        <script>
        var day1 = {
            squirrel: false,
            events: ["work", "touched tree", "pizza", "running",
            "television"]
          };
        </script>
      </em>

    <h4> Creating an array of Objects </h4>
    <p>Array of Objects </p>
      <em>Inspect element to check array of objects sample</em>
      <script>
        var journal = [
          {
            events   : ["work", "touched tree","pizza","running","television"],
            squirrel : false
          },
          {
            events : ["work","ice cream","cauliflower","lasagna","touched tree","brushed teeth"],
            squirrel : false
          },
          {
            events : ["weekend","cycling","break","peanuts","beer"],
            squirrel : true
          },
        ];
      </script>

    <h3>Mutability</h3>
    <p>
    We’ve seen that object values can be modified.
    The types of values discussed in earlier chapters,
    such as numbers, strings, and Booleans, are all immutable—
    it is impossible to change an existing value of those types.
    You can combine them and derive new values from them,
    but when you take a specific string value,
    that value will always remain the same.
    The text inside it cannot be changed.
    If you have reference to a string that contains "cat",
    it is not possible for other code to change a character in
    that string to make it spell "rat".
    </p>
    <br>

    <p>
      <strong>
        With objects, on the other hand,
        the content of a value can be modified by changing its properties.
      </strong>
    </p>
    <br>
    <em> Sample of objects Mutability, open inspect element </em>
    <script>
    var object1 = {value: 10};
    var object2 = object1;
    var object3 = {value: 10};

    console.log(object1 == object2);
    // → true
    console.log(object1 == object3);
    // → false

    object1.value = 15;
    console.log(object2.value);
    // → 15
    console.log(object3.value);
    // → 10
    </script>

    <h3>Further Arrayology</h3>
    <p>Push and pop is to add and remove elements at the end of an array. <br>
      Push to add elements, Pop to remove.
    </p>

    <h4>Coresponding method for adding and removing things at the start of an array called <i>unshift</i> and <i>shift</i></h4>
    <em>Inspect element to see shift and unshift</em>
    <script>
      var todoList = [];
      function remeberTo(task) {
        todoList.push(task);
      }
      function whatIsNext(){
        return todoList.shift();
      }
      function urgentlyRememberTo(task){
        todoList.unshift(task);
      }
    </script>

    <h4>Explanation of the script</h4>
    <p>Previous program manages list of tasks. You add tasks to the end of the list by calling <i>rememberto("eat")</i>, and when you're ready to do something, you call <i>whatIsNext()</i> to get and remove the front item from the list. <br>
    The <i>urgentlyRememberTo</i> function also adds a task but adds it to the front instead of the back of the list.
    </p>

    <h4>Index Of</h4>
    <p>The indexOf method has a sibling called lastIndexOf, which starts searching for the given element at the end of the array instead of the front.</p>

    <p>
      Both indexOf and lastIndexOf take an optional second argument that indicates where to start searching from.
    </p>
    <script>
    console.log([1,2,3,2,1].indexOf(2));
    //1
    console.log([1,2,3,2,1].lastIndexOf(2));
    //3
    </script>

    <h4>Slice</h4>
    <p>
      Slice, takes a start index and an end index and returns an array that has only the elements between those indices.<br>
      The start index is inclusive and the end index exclusive.
    </p>
    <em>Open console log to see whats happening</em>
    <script>
      console.log([0,1,2,3,4].slice(1,4));
      // 1,2,3
      console.log([0,1,2,3,4].slice(2));
      // 2,3,4
    </script>
    <em>When the end index is not given, slice will take all of the elements after the start index</em>

    <script src="chapter4.js" charset="utf-8"></script>
  </body>
</html>
